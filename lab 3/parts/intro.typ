#import "../lib.typ": *
#part_count.step() // Обновление счетчика разделов 
#show: fix-indent()


= Введение <intro> // Название и ссылка на него 
Работа №3. Адаптивное управление линейным Многомерным объектом по состоянию

== Цель работы
Освоение принципов построения адаптивной системы
управления многомерным объектом.


== Методические рекомендации.
До начала работы студенты должны
ознакомиться с принципом построения алгоритмов адаптации на основе
стандартной модели ошибки с измеряемым состоянием [2, 20]. 

== Теоретические сведения
Рассмотрим задачу адаптивного
управления многомерным объектом с использованием эталонной модели.
При этом воспользуемся принципами решения аналогичной задачи для
объекта первого порядка (см. Работу №1).

Постановка задачи. Дан объект:
$ dot(x) =  A x + b u, quad quad x(0)  $ <eq:object-x>
$ y = C x, $ <eq:object-y>
где $x in bb(R)^n$ --- вектор состояния, $u$ --- управление, $y in bb(R)$ --- регулируемая переменная, 
#math.equation(block: true, numbering: none)[
// #set math.mat(delim: "(")
$

  A = mat(
    delim: "[",
    0, 1, 0, ..., 0;
    0, 0, 1, ..., 0;
    dots.v, dots.v, dots.down, dots.down, dots.v;
    0, 0, 0, ..., 1;
    -a_0, -a_1, -a_2, ..., -a_(n-1);
  ),
  b = mat(
    delim: "[",
    0;
    0;
    dots.v;
    0;
    b_0;
  ),
  C = mat(
    delim: "[",
    1, 0, 0, ..., 0;
  ),
$
]
$a_i, i = overline(0","n-1)$ --- неизвестные параметры, $b_0$ --- известный коэффициент.

Задача управления заключается в компенсации параметрической
неопределенности объекта и обеспечении следующего целевого равенства:
$ lim_(t -> oo) ||x_M (t) - x(t)|| = lim_(t -> oo) ||e(t)||=0, $ <eq:target>
где $e=x_M - x$ --- вектор ошибки управления, $x_M in bb(R)^n$ --- вектор,
генерируемый эталонной моделью
$ dot(x)_M = A_M x_M + b_M g, $ <eq:reference-x>
$ y_M = C_M x_M $ <eq:reference-y>
с задающим воздействием $g(t)$ и матрицами
#math.equation(block: true, numbering: none)[
$
A_M = mat(
  delim: "[",
  0, 1, 0, ..., 0;
  0, 0, 1, ..., 0;
  dots.v, dots.v, dots.down, dots.down, dots.v;
  0, 0, 0, ..., 1;
  -a_(M 0), -a_(M 1), -a_(M 2), ..., -a_(M n-1);
),
b_M = mat(
  delim: "[",
  0;
  0;
  dots.v;
  0;
  a_(M 0);
),
C_M = mat(
  delim: "[",
  1, 0, 0, ..., 0;
),
$
]

Параметры эталонной модели $a_(M i), i=overline(1"," n-1)$ строятся на основе
метода стандартных характеристических полиномов [4, 5] для обеспечения
желаемого качества воспроизведения задающего воздействия
$g(t)$. Другими словами, модель @eq:reference-x, @eq:reference-y определяет желаемое качество
замкнутой системы после завершения процессов настройки адаптивного
управления. 

Отметим, что в задаче класс объектов @eq:object-x, @eq:object-y ограничен
следующим допущением.

_Допущение (Условие согласования)._ Для некоторого $n$ -- мерного
вектора $theta$ и скаляра $kappa$ матрицы $A$, $b$, $A_M$ и $b_M$ тсвязаны соотношениями
$ A_M = A + b theta^T, quad b = kappa b_M $ <eq:assumption-condition>

_Решение задачи_. Предполагая параметры объекта известными,
синтезируем регулятор, который обеспечит условие @eq:target с заданными
динамическими показателями качества --- временем переходного процесса $t_"п"$ и перерегулированием $overline(sigma)$.

Для синтеза регулятора сформируем ошибку слежения $e = x_M - x$, рассчитаем ее производную в силу @eq:object-x, @eq:reference-x и условия @eq:assumption-condition:
$
dot(e) &= dot(x_M) - dot(x) = A_M x_M + b_M g - A x - b u \

&= A_M x_M - 1/kappa b g - (A_M - b theta^T) x - b u = A_M e + b(theta^T x - u + 1/kappa g), \
$ <eq:e_dot>
где $theta^T = [theta_1, theta_2, ..., theta_n]$ ---  вектор постоянных параметров, определяемый
параметрическими рассогласованиями между матрицами $A$ и $A_M$,
#math.equation(block: true, numbering: none)[
$
theta_1 = (-a_(M 0) + a_0)/b_0, theta_2 = (-a_(M 1) + a_1)/b_0, ..., theta_n = (-a_(M n-1) + a_(n-1))/b_0, kappa = b_0/b_(M 0).
$
]
--- коэффициенты, рассчитываемые из условия @eq:assumption-condition.

Выражение @eq:e_dot сводится к виду
$ dot(e) = A_M e + b(theta^T x -u + 1/kappa g), $ <eq:error-model>
позволяющему синтезировать управление
$ u = theta^T x + 1/kappa g. $ <eq:non-adaptive-regulator>

После подстановки @eq:non-adaptive-regulator в @eq:error-model получим закон экспоненциальной
сходимости ошибки управления неадаптивной системы: 
#math.equation(block: true, numbering: none)[
  $ dot(e) = A_M e $
]

Однако в исходной постановке задачи параметры матрицы
$A$
неизвестны. Следовательно, закон @eq:non-adaptive-regulator физически нереализуем. Так как
параметры $a_i$ неизвестны, то вектор $theta$
также неизвестен. Заменим в (3.9)
этот вектор на оценку $hat(theta)$ и получим настраиваемый закон управления:
$ u = hat(theta)^T x + 1/kappa g. $ <eq:adaptive-regulator>

Подставим последнее выражение в @eq:error-model и получим модель ошибок
$ dot(e) = A_M e + b tilde(theta)^T x . $ <eq:adaptive-error-model>
где $tilde(theta) = theta - hat(theta)$ --- вектор параметрических ошибок.

Расширяя подход, приведенный в Работе №1, на многомерный
случай, выберем функцию Ляпунова
#math.equation(block: true, numbering: none)[
$
V = 1/2 e^T P e + 1/(2gamma) tilde(theta)^T tilde(theta), \
$
]
где $P = P^T succ 0$ --- положительно определенная симметричная матрица,
удовлетворяющая уравнению Ляпунова
$ A_M^T P + P A_M = -Q $ <eq:lyapunov-equation>
с произвольно выбранной симметричной положительно определенной
матрицей $Q$. Далее, вычисляя производную функции Ляпунова в силу
модели ошибок @eq:adaptive-error-model, получаем:
#math.equation(block: true, numbering: none)[
$
dot(V) = - 1/2 e^T Q e + tilde(theta)^T x b^T P e + 1/gamma tilde(theta)^T  dot(tilde(theta))  \
$
]

Из анализа последнего выражения видно, что если алгоритм адаптации
выбрать в виде
$ dot(hat(theta)) = gamma x b^T P e, quad hat(theta)(0)=0 $ <eq:adaptive-algorithm>
то производная функции Ляпунова будет удовлетворять неравенству
$ dot(V) = - 1/2 e^T Q e <= 0  $ <eq:lyapunov-derivative>
откуда следует выполнение целевого условия @eq:target.

Отметим, что в выражении @eq:adaptive-algorithm коэффициент $gamma>0$ носит название
коэффициента адаптации, и его величина определяет скорость настройки
коэффициентов регулятора @eq:adaptive-regulator.

Таким образом, алгоритм адаптивного управления состоит из
настраиваемого регулятора @eq:adaptive-regulator, алгоритма адаптации @eq:adaptive-algorithm, в котором
матрица $P$ находится из @eq:lyapunov-equation.

Адаптивный регулятор @eq:adaptive-regulator, @eq:adaptive-algorithm, для любых начальных условий $x(0)$, $hat(theta)(0)$ и ограниченного $g$ обеспечивает:
1. ограниченность всех сигналов в замкнутой системе;
2. асимптотическое стремление ошибки $e$ к нулю;
3. ограниченность сигнала $hat(theta)$. Вектор $hat(theta)$ экспоненциально
стремится к $theta$, если вектор $x$ удовлетворяет условию неисчезающего
возбуждения:
$ integral_t^(t+T) x(tau) x^T(tau) dif tau > alpha I $
где $alpha > 0$, $T > 0$ --- постоянные величины.

Условие @eq:lyapunov-derivative эквивалентно условию наличия не менее $(n+1)/2$ гармоник (спектральных линий) в векторе $x$. Отметим, что в рамках
решаемой задачи слежения характер поведения регрессора $x$ целиком
определяется характером задающего воздействия $g$. Поэтому условие
неисчезающего возбуждения может быть переформулировано в терминах
сигнала $g$; 
4. если вектор $x$ удовлетворяет условию @eq:lyapunov-derivative, то существует
оптимальное значение коэффициента $gamma$, при котором скорость сходимости
параметрических ошибок $tilde(theta)$ к нулю максимальна